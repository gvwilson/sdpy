<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="icon" type="image/x-icon" href="../favicon.ico">
<link rel="stylesheet" href="../mccole.css">
<link rel="stylesheet" href="../tango.css">
<script>
  MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)']]
    }
  };
</script>
<script
  type="text/javascript"
  id="MathJax-script"
  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

    <title>Software Design in Python</title>
  </head>
  <body>
    <div class="row">
      <div class="column">
        <h2><a href="../">SDPy</a></h2>
        <ol class="toc-chapter">
  
  <li>
    <a href="../introduction/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../tester/">
      A Testing Framework
    </a>
  </li>
  
  <li>
    <a href="../interpreter/">
      Interpreter
    </a>
  </li>
  
  <li>
    <a href="../dataframe/">
      A Dataframe
    </a>
  </li>
  
  <li>
    <a href="../backup/">
      Versioned File Backups
    </a>
  </li>
  
  <li>
    <a href="../pipeline/">
      A Pipeline Runner
    </a>
  </li>
  
  <li>
    <a href="../builder/">
      A Build Manager
    </a>
  </li>
  
  <li>
    <a href="../matching/">
      Matching Regular Expressions
    </a>
  </li>
  
  <li>
    <a href="../parser/">
      A Regular Expression Parser
    </a>
  </li>
  
  <li>
    <a href="../scraper/">
      Scraping Data
    </a>
  </li>
  
  <li>
    <a href="../server/">
      A Web Server
    </a>
  </li>
  
  <li>
    <a href="../filecache/">
      A File Cache
    </a>
  </li>
  
  <li>
    <a href="../database/">
      Key-Value Store
    </a>
  </li>
  
  <li>
    <a href="../persistence/">
      Object Persistence
    </a>
  </li>
  
  <li>
    <a href="../binary/">
      <strong>Binary Storage</strong>
    </a>
  </li>
  
  <li>
    <a href="../templating/">
      HTML Templating
    </a>
  </li>
  
  <li>
    <a href="../packman/">
      A Package Manager
    </a>
  </li>
  
  <li>
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li>
    <a href="../linter/">
      A Style Checker
    </a>
  </li>
  
  <li>
    <a href="../docgen/">
      A Documentation Generator
    </a>
  </li>
  
  <li>
    <a href="../codegen/">
      A Code Generator
    </a>
  </li>
  
  <li>
    <a href="../vm/">
      A Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      Debugger
    </a>
  </li>
  
  <li>
    <a href="../conclusion/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../bibliography/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contributing/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../links/">
      Links
    </a>
  </li>
  
  <li>
    <a href="../credits/">
      Credits
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

      </div>
      <div class="column bordered">
        <main>
	  
          <h1>Binary Storage</h1>
	  
          
  

  

  

  

  

  

  

  

  

  

  

  
  <ul class="syllabus">
  
  <li markdown="1">FIXME</li>
  
  </ul>
  

  

  

  

  

  

  

  

  


	  
  

  

  

  

  

  
  <p class="definitions">
    Terms defined:
    <a class="gl-ref" href="../glossary/#absolute_error" markdown="1">absolute error</a>, <a class="gl-ref" href="../glossary/#ansi_character" markdown="1">ANSI character encoding</a>, <a class="gl-ref" href="../glossary/#ascii" markdown="1">ASCII character encoding</a>, <a class="gl-ref" href="../glossary/#big_endian" markdown="1">big endian</a>, <a class="gl-ref" href="../glossary/#binary_mode" markdown="1">binary mode</a>, <a class="gl-ref" href="../glossary/#bit_shift" markdown="1">bit shifting</a>, <a class="gl-ref" href="../glossary/#code_point" markdown="1">code point</a>, <a class="gl-ref" href="../glossary/#control_code" markdown="1">control code</a>, <a class="gl-ref" href="../glossary/#exclusive_or" markdown="1">exclusive or</a>, <a class="gl-ref" href="../glossary/#xor" markdown="1">exclusive or (xor)</a>, <a class="gl-ref" href="../glossary/#hexadecimal" markdown="1">hexadecimal</a>, <a class="gl-ref" href="../glossary/#little_endian" markdown="1">little endian</a>, <a class="gl-ref" href="../glossary/#relative_error" markdown="1">relative error</a>, <a class="gl-ref" href="../glossary/#sign_magnitude" markdown="1">sign and magnitude</a>, <a class="gl-ref" href="../glossary/#unicode" markdown="1">Unicode</a>, <a class="gl-ref" href="../glossary/#utf_32" markdown="1">UTF-32</a>, <a class="gl-ref" href="../glossary/#utf_8" markdown="1">UTF-8</a>, <a class="gl-ref" href="../glossary/#variable_length_encoding" markdown="1">variable-length encoding</a>, <a class="gl-ref" href="../glossary/#word_memory" markdown="1">word (of memory)</a>
  </p>
  


          <p>Python and other high-level languages shield programmers from low-level details,
but sooner or later someone has to worry about bits and bytes.
This chapter explores computers represent numbers and text
and how to work with binary data.</p>
<h2 id="binary-int">Section 15.1: Integers</h2>
<p>Let's start by looking at how integers are stored.
The natural way to do this with ones and zeroes is to use base 2,
so 1001 in binary is (1×8)+(0×4)+(0×2)+(1×1) or 9 base 10.
We can handle negative numbers by reserving the top bit for the sign,
so that 01001 is +9 and 11001 is -9.</p>
<p>This representation has two drawbacks.
The minor one is that it gives us two zeroes,
one positive and one negative.
More importantly,
the hardware needed to do arithmetic
on this <a class="gl-ref" href="../glossary/#sign_magnitude" markdown="1">sign and magnitude</a> representation
is more complicated than the hardware needed for another scheme
called {% g twos_complement "two's complement" %].
Instead of mirroring positive values,
two's complement rolls over when going below zero like an odometer.
For example,
with three-bit integers we get the values in <a class="tbl-ref" href="../binary/#binary-3bit">Table 15.1</a></p>
<div class="table"><table id="binary-3bit"><caption>Table 15.1: 3-bit integer values</caption>
<thead>
<tr>
<th>Base 10</th>
<th>Base 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>011</td>
</tr>
<tr>
<td>2</td>
<td>010</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
</tr>
<tr>
<td>0</td>
<td>000</td>
</tr>
<tr>
<td>-1</td>
<td>111</td>
</tr>
<tr>
<td>-2</td>
<td>110</td>
</tr>
<tr>
<td>-3</td>
<td>101</td>
</tr>
<tr>
<td>-4</td>
<td>100</td>
</tr>
</tbody>
</table>
</div>
<p>We can still tell whether a number is positive or negative
by looking at the first bit:
negative numbers have a 1, positives have a 0.
However,
two's complement is asymmetric:
since 0 counts as a positive number,
numbers go from -4 to 3, or -16 to 15, and so on.
As a result,
even if <code>x</code> is a valid number,
<code>-x</code> may not be.</p>
<h3>Writing Binary</h3>
<p>We can write binary numbers directly in Python by using the <code>0b</code> prefix.
For example, <code>0b0011</code> is the number 3.
Programmers usually use <a class="gl-ref" href="../glossary/#hexadecimal" markdown="1">hexadecimal</a> (base 16) instead:
the digits 0–9 have the usual meaning,
and the letters A-F (or a-f) are used to represent the numbers 11–15.
We signal that we're using hexadecimal with a <code>0x</code> prefix,
so <code>0xF7</code> is (15×16)+7 or 247.</p>
<p>Each hexadecimal digit corresponds to four bits (<a class="tbl-ref" href="../binary/#binary-hex">Table 15.2</a>),
which makes it easy to translate bits to digits and vice versa:
for example,
<code>0xF7</code> is <code>0b11110111</code>.
As a bonus,
two hexadecimal digits is exactly one byte.</p>
<div class="table"><table id="binary-hex"><caption>Table 15.2: Bitwise operations</caption>
<thead>
<tr>
<th>Decimal</th>
<th>Hexadecimal</th>
<th>Bits</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0000</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0001</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0010</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>0011</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>0100</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>0101</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>0110</td>
</tr>
<tr>
<td>7</td>
<td>7</td>
<td>0111</td>
</tr>
<tr>
<td>8</td>
<td>8</td>
<td>1000</td>
</tr>
<tr>
<td>9</td>
<td>9</td>
<td>1001</td>
</tr>
<tr>
<td>10</td>
<td>A</td>
<td>1010</td>
</tr>
<tr>
<td>11</td>
<td>B</td>
<td>1011</td>
</tr>
<tr>
<td>12</td>
<td>C</td>
<td>1100</td>
</tr>
<tr>
<td>13</td>
<td>D</td>
<td>1101</td>
</tr>
<tr>
<td>14</td>
<td>E</td>
<td>1110</td>
</tr>
<tr>
<td>15</td>
<td>F</td>
<td>1111</td>
</tr>
</tbody>
</table>
</div>
<h2 id="binary-ops">Section 15.2: Bitwise Operations</h2>
<p>Like most languages based on C,
Python provides four operators for working with bits:
<code>&amp;</code> (and),
<code>|</code> (or),
<code>^</code> (xor),
and <code>~</code> (not).
<code>&amp;</code> yields a 1 only if both its arguments are 1's,
while <code>|</code> yields 1 if either or both of its arguments are 1.
<code>^</code>, called <a class="gl-ref" href="../glossary/#exclusive_or" markdown="1">exclusive or</a> or <a class="gl-ref" href="../glossary/#xor" markdown="1">xor</a>,
produces 1 if either but <em>not</em> both of its arguments are 1.
Putting it another way,
<code>^</code> produces 0 if its inputs are the same and 1 if they are different.
Finally,
<code>~</code> flips its argument: 1 becomes 0, and 0 becomes 1.
When these operators are used on multibit values
they work on corresponding bits independently as shown in <a class="tbl-ref" href="../binary/#binary-ops">Table 15.3</a>.</p>
<div class="table"><table id="binary-ops"><caption>Table 15.3: Bitwise operations</caption>
<thead>
<tr>
<th>Expression</th>
<th>Bitwise</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>12 &amp; 6</code></td>
<td><code>1100 &amp; 0110</code></td>
<td><code>4</code> (<code>0100</code>)</td>
</tr>
<tr>
<td><code>12 | 6</code></td>
<td><code>1100 | 0110</code></td>
<td><code>14</code> (<code>1110</code>)</td>
</tr>
<tr>
<td><code>12 ^ 6</code></td>
<td><code>1100 ^ 0110</code></td>
<td><code>10</code> (<code>1010</code>)</td>
</tr>
<tr>
<td><code>~ 6</code></td>
<td><code>~ 0110</code></td>
<td><code>9</code> (<code>1001</code>)</td>
</tr>
<tr>
<td><code>12 &lt;&lt; 2</code></td>
<td><code>1100 &lt;&lt; 2</code></td>
<td><code>48</code> (<code>110000</code>)</td>
</tr>
<tr>
<td><code>12 &gt;&gt; 2</code></td>
<td><code>1100 &gt;&gt; 2</code></td>
<td><code>3</code> (<code>0011</code>)</td>
</tr>
</tbody>
</table>
</div>
<p>We can set or clear individual bits with these operators.
To set a particular bit,
create a value in which that bit is 1 and the rest are 0.
When this is or'd with a value,
the bit we set is guaranteed to come out 1;
the other bits will be left as they are.
Similarly,
to  set a bit to zero,
create a value in which that bit is 0 and the others are 1,
then use <code>&amp;</code> to combine the two.
To make things easier to read,
programmers often set a single bit,
negative it with <code>~</code>,
and then use <code>&amp;</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">mask</span> <span class="o">=</span> <span class="o">~</span> <span class="mh">0x0100</span>  <span class="c1"># binary 1111 1110 1111 1111</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="c1">#    clears this ^ bit</span>
</code></pre></div>
<p>Most C-inspired languages also provide <a class="gl-ref" href="../glossary/#bit_shift" markdown="1">bit shifting</a> operators.
that move bits left or right.
Shifting the bits <code>0110</code> left by one place produces <code>1100</code>,
while shifting it right by one place produces <code>0011</code>.
In Python,
this is written <code>x &lt;&lt; 1</code> or <code>x &gt;&gt; 1</code>.</p>
<p>Just as shifting a decimal number left corresponds to multiplying by 10,
shifting a binary number left is the same as multiplying it by 2.
Similarly,
shifting a number right corresponds to dividing by 2 and throwing away the remainder,
so <code>17 &gt;&gt; 3</code> is 2.</p>
<p>But what if the top bit of an integer changes from 1 to 0 or vice versa as a result of shifting?
If we're using two's complement,
then the bits <code>1111</code> represent the value -1;
if we shift right we get <code>0111</code> which is 7.
Similarly,
if we shift <code>0111</code> to the left we get <code>1110</code> (assuming we fill in the bottom with 0),
which is -2.</p>
<p>Different languages deal with this problem in different ways.
Python always fills with zeroes.
Java provides two versions of right shift:
<code>&gt;&gt;</code> fills in the high end with zeroes
while <code>&gt;&gt;&gt;</code> copies in the topmost (sign) bit of the original value.
C (and by extension C++) lets the underlying hardware decide,
which means that if you want to be sure of getting a particular answer
you have to handle the top bit yourself.</p>
<h2 id="binary-text">Section 15.3: Text</h2>
<p>The rules for storing text make integers look simple.
By the early 1970s most programs used <a class="gl-ref" href="../glossary/#ascii" markdown="1">ASCII</a>,
which represented unaccented Latin characters using the numbers from 32 to 127.
(The numbers 0 to 31 were used for <a class="gl-ref" href="../glossary/#control_code" markdown="1">control codes</a>
such as newline, carriage return, and bell.)
Since computers use 8-bit bytes and the numbers 0–127 only need 7 bits,
programmers were free to use the numbers 128–255 for other characters.
Unfortunately,
different pieces of software used them to represent different symbols:
non-Latin characters,
graphic characters like boxes,
and so on.
The chaos was eventually tamed by the <a class="gl-ref" href="../glossary/#ansi_character" markdown="1">ANSI</a> standard
which (for example) defined the value 231 to mean the character "ç".</p>
<p>But the ANSI standard only solved part of the problem.
The ANSI standard didn't include characters from Turkish, Devanagari, and many other alphabets,
much less the thousands of characters used in some East Asian writing systems.
One solution would have been to use 16 or even 32 bits per character,
but:</p>
<ol>
<li>existing text files using ANSI would have to be transcribed, and</li>
<li>documents would be two or four times larger.</li>
</ol>
<p>The solution was a new standard called <a class="gl-ref" href="../glossary/#unicode" markdown="1">Unicode</a> with two parts.
The first part defined a <a class="gl-ref" href="../glossary/#code_point" markdown="1">code point</a> for every character:
U+0065 for an upper-case Latin "A",
U+2605 for a black star,
and so on.
The second part defined ways to store these values in memory.
The simplest of these is <a class="gl-ref" href="../glossary/#utf_32" markdown="1">UTF-32</a>,
which stores every character as a 32-bit number.
This wastes a lot of memory—if the text is written in a Western European language,
UTF-32 uses four times as much storage as necessary—but
since each character is exactly the same size it's very easy to process.</p>
<p>The most popular encoding is <a class="gl-ref" href="../glossary/#utf_8" markdown="1">UTF-8</a>,
which is a <a class="gl-ref" href="../glossary/#variable_length_encoding" markdown="1">variable length encoding</a>.
Every code point from 0 to 127 is stored in a single byte whose high bit is 0,
just as it was in the original ASCII standard.</p>
<p>What if the high bit in the byte is 1?
In that case,
the number of 1's after the high bit but before the first 0
tells UTF-8 how many more bytes that character is using.
For example,
if the first byte of the character is <code>11101101</code> then:</p>
<ul>
<li>the first 1 signals that this is a multi-byte character;</li>
<li>the next two 1's signal that the character includes bits
    from the following two bytes as well as this one;</li>
<li>the 0 separates the byte count from the first few bits used in the character;
    and</li>
<li>the final 1101 is the first four bits of the character.</li>
</ul>
<p>But that's not all:
every byte that's a continuation of a character starts with 10.
This rule means that if we look at any byte in a string
we can immediately tell if it's the start of a character
or the continuation of a character.
Thus,
if we want to represent a character whose code point is 1789:</p>
<ul>
<li>We convert to binary 11011111101.</li>
<li>We count and realize that we'll need two bytes:
    the first storing the high 5 bits of the character,
    the second storing the low 6 bits.</li>
<li>We encode the high 5 bits as 11011011,
    meaning "start of a character with one continuation byte
    and the 5 payload bits 11011".</li>
<li>We encode the low 6 bits as 10111101,
    meaning "a continuation byte with 6 payload bits 111101".</li>
</ul>
<h2 id="binary-fp">Section 15.4: Floating Point Numbers</h2>
<p>The rules for floating point numbers make Unicode look simple.
The root of the problem is that
we cannot represent an infinite number of real values
with a finite set of bit patterns.
And no matter what values we represent,
there will be an infinite number of values between each of them that we can't.</p>
<div class="callout">
<h3>Go to the source</h3>
<p>The explanation that follows is simplified to keep it manageable.
If you're doing any calculation on a computer at all,
please read <span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Goldberg1991">Goldberg1991</a>]</span>.</p>
</div>
<p>Floating point numbers are represented by a sign,
a magnitude,
and an exponent.
In a 32-bit <a class="gl-ref" href="../glossary/#word_memory" markdown="1">word</a>
the IEEE 754 standard calls for 1 bit of sign,
23 bits for the magnitude (or mantissa),
and 8 bits for the exponent.
We will illustrate how it works using a much smaller representation:
no sign,
3 bits for the magnitude,
and 2 for the exponent.</p>
<p><span class="FIXME">FIXME</span></p>
<p>There is a lot of redundancy here
which the IEEE standard avoids by shifting things around.
More importantly,
this format can't represent a lot of values:
for example,
it can store 8 and 10 but not 9.
This is exactly like the problem hand calculators have
with fractions like 1/3:
in decimal, we have to round that to 0.3333 or 0.3334.</p>
<p>But if this scheme has no representation for 9
then 8+1 must be stored as either 8 or 10.
If that's so,
then what is 8+1+1?
If we add from the left,
(8+1)+1 is 8+1 is 8,
but if we add from the right,
8+(1+1) is 8+2 is 10.
Changing the order of operations makes the difference between right and wrong.</p>
<p>The authors of numerical libraries spend a lot of time worrying about things like this.
In this case
sorting the values and then add from smallest to largest
gives the best chance of getting the best possible answer.
In other situations,
like inverting a matrix, the rules are much more complicated.</p>
<p>Another observation about our uneven number line is that
the we can represent are unevenly spaced.
However,
the <em>relative</em> spacing between each set of values stays the same:
the first group is separated by 1,
then the separation becomes 2,
then 4,
and so on.
This points us at a couple of useful definitions:</p>
<ul>
<li>
<p>The <a class="gl-ref" href="../glossary/#absolute_error" markdown="1">absolute error</a> in an approximation
    is the absolute value of the difference
    between the approximation and the actual value.</p>
</li>
<li>
<p>The <a class="gl-ref" href="../glossary/#relative_error" markdown="1">relative error</a>
    is the ratio of the absolute error
    to the absolute value we're approximating.</p>
</li>
</ul>
<p>For example,
being off by 1 in approximating 8+1 and 56+1 is the same absolute error,
but the relative error is larger in the first case than in the second.
Relative error is almost always more useful than absolute:
it makes little sense to say that we're off by a hundredth
when the value in question is a billionth.</p>
<p>One implication of this is that
we should never compare floating point numbers with <code>==</code> or <code>!=</code>
because two numbers calculated in different ways
will probably not have exactly the same bits.
It's safe to use <code>&lt;</code>, <code>&gt;=</code>, and other orderings,
though,
since they don't depend on being the same down to the last bit.</p>
<p>If we do want to compare floating point numbers
we can use something like <a href="https://docs.pytest.org/en/4.6.x/reference.html#pytest-approx">the <code>approx</code> class</a> from <a href="https://docs.pytest.org/">pytest</a>
which checks whether two numbers are within some tolerance of each other.
A completely different approach is to use something like
<a href="https://docs.python.org/3/library/fractions.html">the <code>fractions</code> package</a>,
which (as its name suggests) uses numerators and denominators
to avoid some precision issues.
<a href="https://www.textualize.io/blog/posts/7-things-about-terminals">This post</a> describes one clever use of the package.</p>
<h2 id="binary-binary">Section 15.5: And Now, Persistence</h2>
<p>So why store data in a format that can't be edited with Notepad or nano?
There are generally four reasons:</p>
<dl>
<dt>Size</dt>
<dd>The string <code>"10239472"</code> is 8 bytes long,
but the 32-bit integer it represents only needs 4 bytes in memory.
This doesn't matter for small data sets,
but it does for large ones,
and it definitely does when data has to move between disk and memory
or between different computers.</dd>
<dt>Speed</dt>
<dd>Adding the integers 34 and 56 is a single machine operation.
Adding the values represented by the strings <code>"34"</code> and <code>"56"</code> is dozens;
we'll explore this in the exercises.
Most programs that read and write text files
convert the values in those files into binary data
using something like the <code>int</code> or <code>float</code> functions,
but if we're going to process the data many times,
it makes sense to avoid paying the conversion cost over and over.</dd>
<dt>Hardware</dt>
<dd>Someone, somewhere, has to convert the signal from the thermocouple to a number,
and that signal probably arrives arrives as a stream of 1's and 0's.</dd>
<dt>Lack of anything better</dt>
<dd>It's possible to represent images as ASCII art, but sound?
Or video?
It would be possible, but it would hardly be sensible.</dd>
</dl>
<p>Most programs use line-oriented file I/O:
they read characters until they see an end-of-line marker
and then hand back those characters as a string.
We can also use byte-oriented routines,
the most basic of which is simply called <code>read</code>.
If <code>stream</code> is an open file,
then <code>stream.read(N)</code> hands back up to the next N bytes from the file
("up to", because there might not be that much data left).
The result is returned as a string,
but---and this is crucial---there is no guarantee that the values represent characters.
We can concatenate other data onto it,
but if the underlying file is a PNG image,
text-oriented methods like <code>string.upper</code>
won't do anything meaningful.</p>
<p><span class="FIXME">FIXME</span></p>
<p>Where there's a <code>read</code> there's a <code>write</code>.
<code>stream.write(str)</code> writes the bytes in the string <code>str</code> to a file that has been opened for writing.
In both the reading and writing cases,
though,
it's very important to open the file in <a class="gl-ref" href="../glossary/#binary_mode" markdown="1">binary mode</a> using either:</p>
<div class="highlight"><pre><span></span><code><span class="n">reader</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;input.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
</code></pre></div>
<p class="continue">or:</p>
<div class="highlight"><pre><span></span><code><span class="n">writer</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;input.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
</code></pre></div>
<p>The <code>"b"</code> at the end of the mode string tells Python
<em>not</em> to translate Windows line endings (which are the two characters <code>"\r\n"</code>)
into Unix line endings (the single character <code>"\n"</code>).
This translation is handy when we're working with text,
since it means our programs only have to deal with one style of line
ending no mater what platform the code is running on,
but it messes up non-textual data.</p>
<p>There's another problem here as well.
C and Fortran store integers as "naked" 32-bit values:
the program uses what the machine provides,
no more and no less.
Python and other dynamic languages usually don't use raw values.
Instead,
they put the value in a larger data structure
that keeps track of its type along with a bit of extra administrative information.
That extra data allows those languages to do garbage collection.
It also allows us to assign values to variables without explicitly declaring their type,
since the value we're assigning carries its type along with it.</p>
<p>A similar issue comes up when we compare Fortran's arrays to Python's lists.
Fortran stores the data in an array side by side in one big block of memory.
Writing this to disk is easy:
if the array starts at location L in memory and has N values,
each of which is B bytes long,
we just copy the bytes from L to L+NB-1 to the file.</p>
<p>A Python list,
on the other hand,
stores pointers to values rather than the values themselves.
To put the values in a file
we can either write them one at a time
or pack them into a contiguous block and write that.
Similarly,
when reading from a file,
we can either grab the values one by one
or read a larger block and then unpack it in memory.</p>
<p>Packing data is a lot like formatting values for textual output.
The format specifies what types of data are being packed,
how big they are (e.g., is this a 32-bit or 64-bit floating point number?),
and how many values there are.
The format exactly determines how much memory is required by the packed representation.
The result of packing values is a block of bytes,
which Python represents as a string,
but as mentioned above,
this isn't a string of characters.</p>
<p>Unpacking reverses this process.
After reading data into memory
we can unpack it according to a format.
The most important thing is that
<em>we can unpack data any way we want</em>.
We might pack an integer and then unpack it as four characters,
since both are 32 bits long.
Or we might save two characters,
an integer,
and two more characters,
then unpack it as a 64-bit floating point number.
The bits are just bits:
it's our responsibility to make sure we keep track of their meaning
when they're down there on disk.</p>
<p>In Python we can use the <code>struct</code> module to pack and unpack data.
The function <code>pack(format, val_1, val_2, …)</code>
takes a format string and a bunch of values as arguments,
packs them into a string,
and gives that back to us.
The inverse function, <code>unpack(format, string)</code> takes such a string and a format
and returns a tuple containing the unpacked values.
Here's an example:</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">struct</span>

<span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;ii&quot;</span> <span class="c1"># two 32-bit integers</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">31</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">65</span>

<span class="n">binary</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;binary representation:&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">binary</span><span class="p">))</span>

<span class="n">normal</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">binary</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;back to normal:&quot;</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>binary representation: b&#39;\x1f\x00\x00\x00A\x00\x00\x00&#39;
back to normal: (31, 65)
</code></pre></div>
<p>What is <code>\x1f</code> and why is it in our data?
If Python finds a character in a string that doesn't have a printable representation,
it prints a 2-digit escape sequence in <a class="gl-ref" href="../glossary/#hexadecimal" markdown="1">hexadecimal</a> (base 16).
This uses the letters A-F (or a-f) to represent the digits from 10 to 15,
so that (for example) <code>3D5</code> is (3×16^2^)+(13×16^1^)+(5×16^0^), or 981 in decimal.
Python is therefore telling us that
our string contains the eight bytes
<code>['\x1f', '\x00', '\x00', '\x00', 'A', '\x00', '\x00', '\x00']</code>.
<code>1F</code> in hex is (1×16^1^)+(15×16^0^), or 31;
<code>'A'</code> is our 65,
because the ASCII code for an upper-case letter A is the decimal value 65.
All the other bytes are zeroes (<code>"\x00"</code>)
because each of our integers is 32 bits long
and the significant digits only fill one byte's worth of each.</p>
<div class="table"><table id="binary-formats"><caption>Table 15.4: `struct` package formats</caption>
<thead>
<tr>
<th>Format</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>"c"</code></td>
<td>Single character (i.e., string of length 1)</td>
</tr>
<tr>
<td><code>"B"</code></td>
<td>Unsigned 8-bit integer</td>
</tr>
<tr>
<td><code>"h"</code></td>
<td>Short (16-bit) integer</td>
</tr>
<tr>
<td><code>"i"</code></td>
<td>32-bit integer</td>
</tr>
<tr>
<td><code>"f"</code></td>
<td>32-bit float</td>
</tr>
<tr>
<td><code>"d"</code></td>
<td>Double-precision (64-bit) float</td>
</tr>
</tbody>
</table>
</div>
<p>The <code>struct</code> module offers a lot of different formats,
some of which are shown in <a class="tbl-ref" href="../binary/#binary-formats">Table 15.4</a>.
The <code>"B"</code>, <code>"h"</code>, and <code>"2"</code> formats deserve some explanation.
<code>"B"</code> takes the least significant 8 bits out of an integer and packs those;
<code>"h"</code> takes the least significant 16 bits and does likewise.
They're needed because binary data formats often store only as much data as they need to,
so we need a way to get 8- and 16-bit values out of files.
(Many audio formats,
for example,
only store 16 bits per sample.)</p>
<p>Any format can be preceded by a count,
so the format <code>"3i"</code> means "three integers":</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>

<span class="nb">print</span><span class="p">(</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;3i&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;5s&quot;</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;5s&quot;</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">(</span><span class="s2">&quot;a longer string&quot;</span><span class="p">,</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">)))</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>b&#39;\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00&#39;
b&#39;hello&#39;
b&#39;a lon&#39;
</code></pre></div>
<p>We get the wrong answer in the last call
because we only told Python to pack five characters.
How can we tell it to pack all the data that's there regardless of length?</p>
<p>The short answer is that we can't:
we must specify how much we want packed.
But that doesn't mean we can't handle variable-length strings;
it just means that we have to construct the format on the fly:</p>
<div class="highlight"><pre><span></span><code><span class="nb">format</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span>
</code></pre></div>
<p><code>len(str)</code> is just the length of the string <code>str</code>,
so if <code>str</code> contains the string <code>"example"</code>,
the expression above will assign the string <code>"7s"</code> to <code>format</code>,
which just happens to be exactly the right format to use to pack it.</p>
<p>That's fine when we're writing,
but how do we know how much data to get if we're reading?
For example, suppose we have the two strings "hello" and "Python".
we can pack them like this:</p>
<div class="highlight"><pre><span></span><code><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;5s6s&#39;</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;Python&#39;</span><span class="p">)</span>
</code></pre></div>
<p class="continue">but how do I know how to unpack 5 characters then 6?
The trick is to save the size along with the data.
If we always use exactly the same number of bytes to store the size,
we can read it back safely,
then use it to figure out how big our string is:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">pack_string</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">header</span> <span class="o">=</span> <span class="n">pack</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>
<span class="o">...</span>     <span class="n">body_format</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="o">...</span>     <span class="n">body</span> <span class="o">=</span> <span class="n">pack</span><span class="p">(</span><span class="n">body_format</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">header</span> <span class="o">+</span> <span class="n">body</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pack_string</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="s1">&#39;</span><span class="se">\x05\x00\x00\x00</span><span class="s1">hello&#39;</span>
</code></pre></div>
<p>The unpacking function is almost the same:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">unpack_string</span><span class="p">(</span><span class="n">buffer</span><span class="p">):</span>
<span class="o">...</span>    <span class="n">header</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[:</span><span class="mi">4</span><span class="p">],</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
<span class="o">...</span>    <span class="n">unpacked_header</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
<span class="o">...</span>    <span class="n">length</span> <span class="o">=</span> <span class="n">unpacked_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">...</span>    <span class="n">body_format</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="n">length</span>
<span class="o">...</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">body_format</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>
<span class="o">...</span>    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
<p>First, we break the buffer into two parts:
a header that's exactly four bytes long
(i.e., the right size for an integer)
and a body made up of whatever's left.
We then unpack the header,
whose format we know,
to determine how many characters are in the string.
Once we've got that we use the trick shown earlier
to construct the right format on the fly
and then unpack the string and return it.</p>
<p>Something else to notice here is that
the least significant byte of an integer comes first.
This is called <a class="gl-ref" href="../glossary/#little_endian" markdown="1">little-endian</a> and is used by all Intel processors.
Some other processors put the most significant byte first,
which is called <a class="gl-ref" href="../glossary/#big_endian" markdown="1">big-endian</a>.
There are pro's and con's to both, which we won't go into here.
What you <em>do</em> need to know is that if you move data from one architecture to another,
it's your responsibility to flip the bytes around,
because the machine doesn't know what the bytes mean.
This is such a pain that the <code>struct</code> library and other libraries like
will do things for you if you ask it to.
If you're using <code>struct</code>,
the first character of a format string optionally indicates the byte order
(<a class="tbl-ref" href="../binary/#binary-endian">Table 15.5</a>).</p>
<div class="table"><table id="binary-endian"><caption>Table 15.5: `struct` package endian indicators</caption>
<thead>
<tr>
<th>Character</th>
<th>Byte order</th>
<th>Size</th>
<th>Alignment</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@</code></td>
<td>native</td>
<td>native</td>
<td>native</td>
</tr>
<tr>
<td><code>=</code></td>
<td>native</td>
<td>standard</td>
<td>none</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>little</td>
<td>endian</td>
<td>standard none</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>big</td>
<td>endian</td>
<td>standard none</td>
</tr>
<tr>
<td><code>!</code></td>
<td>network</td>
<td>standard</td>
<td>none</td>
</tr>
</tbody>
</table>
</div>
<p>You should also use the <code>struct</code> library's <code>calcsize</code> function,
which tells you how large (in bytes) the data produced or consumed by a format will be.
For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;4s&#39;</span><span class="p">)</span>
<span class="mi">4</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;3i4s5d&#39;</span><span class="p">)</span>
<span class="mi">56</span>
</code></pre></div>
<p>Binary data is to programming what chemistry is to biology:
you don't want to spend any more time thinking at its level than you have to,
but there's no substitute when you <em>do</em> have to.
Please remember that libraries already exist to handle almost every binary format ever created
and to read data from almost every instrument on the market.
You shouldn't worry about 1's and 0's unless you really have to.</p>
<h2 id="binary-exercises">Section 15.6: Exercises</h2>
<p>FIXME</p>
<h3 class="exercise">Adding strings</h3>
<p>Write a function that takes two strings of digits
and adds them as if they were numbers
<em>without</em> actually converting them to numbers.
For example,
<code>add_str("12", "5")</code> should produce the string <code>"17"</code>.</p>
<h3 class="exercise">Roundoff</h3>
<ol>
<li>Write a program that loops over the integers from 1 to 9
    and uses them to create the values 0.9, 0.09, and so on.</li>
<li>Calculate the same values by subtracting 0.1 from 1,
    then subtracting 0.01,
    and so on.</li>
<li>Calculate the absolute and relative differences between corresponding values
    (which should be identical).</li>
<li>Repeat the exercise using the <code>Fraction</code> class
    from the <a href="https://docs.python.org/3/library/fractions.html"><code>fractions</code></a> package.</li>
</ol>
        </main>
      </div>
    </div>
  </body>
</html>
