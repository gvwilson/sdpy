<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="icon" type="image/x-icon" href="../favicon.ico">
<link rel="stylesheet" href="../mccole.css">
<link rel="stylesheet" href="../tango.css">
<script>
  MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)']]
    }
  };
</script>
<script
  type="text/javascript"
  id="MathJax-script"
  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

    <title>Software Design in Python</title>
  </head>
  <body>
    <div class="row">
      <div class="column">
        <h2><a href="../">SDPy</a></h2>
        <ol class="toc-chapter">
  
  <li>
    <a href="../introduction/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../tester/">
      A Testing Framework
    </a>
  </li>
  
  <li>
    <a href="../interpreter/">
      Interpreter
    </a>
  </li>
  
  <li>
    <a href="../dataframe/">
      <strong>A Dataframe</strong>
    </a>
  </li>
  
  <li>
    <a href="../backup/">
      Versioned File Backups
    </a>
  </li>
  
  <li>
    <a href="../pipeline/">
      A Pipeline Runner
    </a>
  </li>
  
  <li>
    <a href="../builder/">
      A Build Manager
    </a>
  </li>
  
  <li>
    <a href="../matching/">
      Matching Regular Expressions
    </a>
  </li>
  
  <li>
    <a href="../parser/">
      A Regular Expression Parser
    </a>
  </li>
  
  <li>
    <a href="../server/">
      A Web Server
    </a>
  </li>
  
  <li>
    <a href="../filecache/">
      A File Cache
    </a>
  </li>
  
  <li>
    <a href="../database/">
      Key-Value Store
    </a>
  </li>
  
  <li>
    <a href="../persistence/">
      Object Persistence
    </a>
  </li>
  
  <li>
    <a href="../binary/">
      Binary Storage
    </a>
  </li>
  
  <li>
    <a href="../templating/">
      HTML Templating
    </a>
  </li>
  
  <li>
    <a href="../packman/">
      A Package Manager
    </a>
  </li>
  
  <li>
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li>
    <a href="../linter/">
      A Style Checker
    </a>
  </li>
  
  <li>
    <a href="../docgen/">
      A Documentation Generator
    </a>
  </li>
  
  <li>
    <a href="../codegen/">
      A Code Generator
    </a>
  </li>
  
  <li>
    <a href="../vm/">
      A Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      Debugger
    </a>
  </li>
  
  <li>
    <a href="../conclusion/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../bibliography/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contributing/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../links/">
      Links
    </a>
  </li>
  
  <li>
    <a href="../credits/">
      Credits
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

      </div>
      <div class="column bordered">
        <main>
	  
          <h1>A Dataframe</h1>
	  
          
  

  

  
  <ul class="syllabus">
  
  <li markdown="1">Create abstract base classes to specify interfaces.</li>
  
  <li markdown="1">Store two-dimensional data as rows or as columns.</li>
  
  <li markdown="1">Use reflection to match data to function parameters.</li>
  
  <li markdown="1">Measure performance to evaluate engineering tradeoffs.</li>
  
  </ul>
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  


	  
  

  

  

  
  <p class="definitions">
    Terms defined:
    <a class="gl-ref" href="../glossary/#abstract_base_class" markdown="1">abstract base class</a>, <a class="gl-ref" href="../glossary/#benchmark" markdown="1">benchmark</a>, <a class="gl-ref" href="../glossary/#column_wise" markdown="1">column-wise storage</a>, <a class="gl-ref" href="../glossary/#concrete_class" markdown="1">concrete class</a>, <a class="gl-ref" href="../glossary/#immutable" markdown="1">immutable</a>, <a class="gl-ref" href="../glossary/#index_database" markdown="1">index (a database)</a>, <a class="gl-ref" href="../glossary/#join" markdown="1">join (tables)</a>, <a class="gl-ref" href="../glossary/#row_wise" markdown="1">row-wise storage</a>
  </p>
  

  

  


          <p>Whether your tool of choice is Python, R, SQL, or Excel,
you're almost certainly doing data science on tables
with named columns that have the same type of value in every row.
To explore how they work,
we build two implementations of dataframes in Python:
one that stores values in columns,
the other that stores them in rows.
And to explain how to choose between them,
we measure their performance.</p>
<h2 id="dataframe-cols">Section 4.1: Storing Columns</h2>
<p>We start by creating an <a class="gl-ref" href="../glossary/#abstract_base_class" markdown="1">abstract base class</a>
that defines the methods our two dataframe classes will support.
This class (unimaginatively called <code>DF</code>)
requires <a class="gl-ref" href="../glossary/#concrete_class" markdown="1">concrete classes</a> to implement eight methods:</p>
<ul>
<li><code>ncol</code>: report the number of columns.</li>
<li><code>nrow</code>: report the number of rows.</li>
<li><code>cols</code>: return the set of column names.</li>
<li><code>eq</code>: check whether this dataframe is equal to another.</li>
<li><code>get</code>: get a scalar value from a specified column and row.</li>
<li><code>set</code>: set the scalar value in a specified column and row.</li>
<li><code>select</code>: create a new dataframe containing some or all of the original's columns.</li>
<li><code>filter</code>: create a new dataframe containing some or all of the original's rows.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span>

<span class="k">class</span> <span class="nc">DF</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dataframe interface.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">ncol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Report the number of columns.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">nrow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Report the number of rows.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">cols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the set of column names.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check equality of two dataframes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a scalar value.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select a subset of columns.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select a subset of rows.&quot;&quot;&quot;</span>
</code></pre></div>
<div class="callout">
<h3>Docstrings are enough</h3>
<p><span class="FIXME">FIXME</span></p>
</div>
<p>We then derive a class <code>DfCol</code> that uses <a class="gl-ref" href="../glossary/#column_wise" markdown="1">column-wise</a> storage.
Each column is stored as a list of values,
all of which are of the same type.
The dataframe is a dictionary of such lists,
all of which have the same length:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">df_base</span> <span class="kn">import</span> <span class="n">DF</span>


<span class="k">class</span> <span class="nc">DfCol</span><span class="p">(</span><span class="n">DF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Column-wise dataframe.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize from `name=[values]`.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">all_eq</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">all_eq</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">kwargs</span>
</code></pre></div>
<p>Some methods are almost trivial to implement on top of this storage mechanism;
others are more difficult.
Three of the easy ones return the number of rows and columns
and the names of the columns:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">ncol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Report the number of columns.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nrow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Report the number of rows.&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">cols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the set of column names.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</code></pre></div>
<p><span class="FIXME">FIXME</span></p>
<p>Testing for equality is also relatively simple.
Two dataframes are the same if they have exactly the same columns
and the same values in every column:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check equality of two dataframes.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DF</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">cols</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">n</span><span class="p">])):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>
<p class="continue">Notice that we use <code>other.cols()</code> and <code>other.get()</code>
rather than reaching into the other dataframe.
We defined the abstract base class because
we expect to implement dataframes in several different ways.
Those other ways will probably not use the same data structures,
so we can only rely on the interface defined in the base class.</p>
<p>Getting individual values is straightforward:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a scalar value.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">row</span><span class="p">]</span>
</code></pre></div>
<p class="continue">Selecting a subset of columns is also straightforward:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select a subset of columns.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DfCol</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">n</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">})</span>
</code></pre></div>
<p class="continue">Notice,
though,
that the dataframe created by <code>select</code>
re-uses the columns of the original dataframe.
This is safe and efficient so long as columns are <a class="gl-ref" href="../glossary/#immutable" markdown="1">immutable</a>,
i.e.,
so long as their contents are never changed in place.</p>
<p>Time to write some tests.
This one checks that we can construct a dataframe with some values:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_construct_with_two_pairs</span><span class="p">():</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">DfCol</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>
</code></pre></div>
<p class="continue">while this one checks that <code>filter</code> works correctly:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_filter</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">odd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">DfCol</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">odd</span><span class="p">)</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">DfCol</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
</code></pre></div>
<h2>Storing Rows</h2>
<p>Column-wise storage makes selecting columns easy but filtering rows hard.
If we expect to do more filtering than selecting
it might be more efficient to use <a class="gl-ref" href="../glossary/#row_wise" markdown="1">row-wise</a> storage.
The class <code>DfRow</code> is derived from the same abstract base class <code>DF</code> as <code>DfCol</code>,
so it has to have the same interface.
However,
it stores data as a single list of dictionaries,
each with the same keys and the same types of values:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">df_base</span> <span class="kn">import</span> <span class="n">DF</span>


<span class="k">class</span> <span class="nc">DfRow</span><span class="p">(</span><span class="n">DF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Row-wise dataframe.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize from a list of rows.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">dict_match</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">rows</span>
</code></pre></div>
<p class="continue">Notice that <code>DfRow</code>'s constructor <em>doesn't</em> have the same signature as <code>DfCol</code>.
At some point in our code we have to decide which of the two classes to construct.
If we design our code well that decision will be made in exactly one place
and everything else will rely solely on the common interface defined by <code>DF</code>.
But since we have to type something different at the point of construction,
it's OK for the constructors to be different.</p>
<p>The basic operations <code>ncol</code>, <code>nrow</code>, and <code>cols</code> are straightforward:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">ncol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Report the number of columns.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">nrow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Report the number of rows.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the set of column names.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</code></pre></div>
<p class="continue">Whenever we need information about columns,
we look at the first row.
The assumption that there <em>is</em> a first row means we can't represent
an empty dataframe;
we'll explore this in the exercises.</p>
<p>Getting values and checking for equality are also straightforward.
(See the source code for their implementation.)
Selecting and filtering are more interesting,
since they are the whole point of this implementation.
To select columns we must build a new list of dictionaries,
each of which has only some of the keys of the original:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select a subset of columns.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[{</span><span class="n">key</span><span class="p">:</span><span class="n">r</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">names</span><span class="p">}</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">DfRow</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</code></pre></div>
<p class="continue">To filter,
we simply pass each row to the user-supplied filter function:</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select a subset of rows.&quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="o">**</span><span class="n">r</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">DfRow</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div>
<p>These operations are the inverses of their <code>DfCol</code> counterparts:
we have to rearrange data to select
but can use the existing data as-is to filter
rather than vice versa.</p>
<p>Since <code>DfCol</code> and <code>DfRow</code> have the same interface,
we can recycle the tests we wrote for the former.
We obviously need to change the objects we construct,
so let's use this opportunity to write helper functions
to create the dataframes we use in multiple tests:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">odd_even</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">DfRow</span><span class="p">([{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}])</span>


<span class="k">def</span> <span class="nf">a_only</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">DfRow</span><span class="p">([{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}])</span>
</code></pre></div>
<p>Creating fixtures in functions is so common
that <a href="https://docs.pytest.org/">pytest</a> has built-in support for it;
we will explore this in the exercises.
With these functions in hand our tests look like:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_construct_with_two_pairs</span><span class="p">():</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">odd_even</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>
</code></pre></div>
<h2 id="dataframe-performance">Section 4.3: Performance</h2>
<p>So how do our two classes perform?
To find out,
let's write a short program to create dataframes of each kind
and then time how long it takes to select their columns and filter their rows.
To keep things simple
we will create dataframes whose columns are called <code>label_1</code>, <code>label_2</code>, and so on,
and whose values are all integers in the range 0–9.
A thorough set of <a class="gl-ref" href="../glossary/#benchmark" markdown="1">benchmarks</a> would create columns of other kinds as well,
but this is enough to illustrate the technique.</p>
<div class="highlight"><pre><span></span><code><span class="n">SPREAD</span> <span class="o">=</span> <span class="mi">10</span>


<span class="k">def</span> <span class="nf">make_col</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a column-oriented dataframe.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_col</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[((</span><span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">SPREAD</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="n">fill</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;label_</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">_col</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncol</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">DfCol</span><span class="p">(</span><span class="o">**</span><span class="n">fill</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">make_row</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a row-oriented dataframe.&quot;&quot;&quot;</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;label_</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncol</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_row</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">c</span><span class="p">:((</span><span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">SPREAD</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">)}</span>

    <span class="n">fill</span> <span class="o">=</span> <span class="p">[</span><span class="n">_row</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrow</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">DfRow</span><span class="p">(</span><span class="n">fill</span><span class="p">)</span>
</code></pre></div>
<p>To time filtering,
we arbitrarily decide that we will keep rows an even value in the first column.
Again,
if we were doing this for real
we would look at some actual programs
to see what fraction of rows filtering usually kept,
and then model that.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">time_filter</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Time filtering operation.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">label_0</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">label_0</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
</code></pre></div>
<p class="continue">Notice that <code>time_filter</code> doesn't know or care
whether it's being given a <code>DfCol</code> or a <code>DfRow</code>.
That's the whole point of deriving them from a base class:
we can use them interchangeably.</p>
<p>Timing <code>select</code> is similar to timing <code>filter</code>.
Again,
we make an arbitrary decision about how many columns to keep
(in this case one third):</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">time_select</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Time selection operation.&quot;&quot;&quot;</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">ncol</span><span class="p">())</span> <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;label_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">labels</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
</code></pre></div>
<p>Finally,
we write a function that takes a list of strings like <code>3x3</code> or <code>100x20</code>,
creates a dataframe of each kind and of each size,
times operations,
and reports the results:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">sweep</span><span class="p">(</span><span class="n">sizes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Time operations on various sizes of dataframes.&quot;&quot;&quot;</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">]</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">]</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;nrow&quot;</span><span class="p">,</span> <span class="s2">&quot;ncol&quot;</span><span class="p">,</span> <span class="s2">&quot;filter col&quot;</span><span class="p">,</span> <span class="s2">&quot;select col&quot;</span><span class="p">,</span> <span class="s2">&quot;filter row&quot;</span><span class="p">,</span> <span class="s2">&quot;select row&quot;</span><span class="p">]]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">:</span>
        <span class="n">df_col</span> <span class="o">=</span> <span class="n">make_col</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span>
        <span class="n">df_row</span> <span class="o">=</span> <span class="n">make_row</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
            <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">,</span>
            <span class="n">time_filter</span><span class="p">(</span><span class="n">df_col</span><span class="p">),</span> <span class="n">time_select</span><span class="p">(</span><span class="n">df_col</span><span class="p">),</span>
            <span class="n">time_filter</span><span class="p">(</span><span class="n">df_row</span><span class="p">),</span> <span class="n">time_select</span><span class="p">(</span><span class="n">df_row</span><span class="p">)</span>
        <span class="p">])</span>
    <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span><span class="o">.</span><span class="n">writerows</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</code></pre></div>
<p>The results are shown in <a class="tbl-ref" href="../dataframe/#dataframe-timing">Table 4.1</a>.
For a 1000 by 1000 dataframe
selection is over 250 times faster with column-wise storage than with row-wise,
while filtering is 1.8 times slower.
<span class="FIXME">FIXME</span></p>
<div class="table"><table id="dataframe-timing"><caption>Table 4.1: Dataframe timings</caption>
<thead>
<tr>
<th>nrow</th>
<th>ncol</th>
<th>filter col</th>
<th>select col</th>
<th>filter row</th>
<th>select row</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>10</td>
<td>8.87e-05</td>
<td>7.70e-05</td>
<td>4.41e-05</td>
<td>2.50e-05</td>
</tr>
<tr>
<td>100</td>
<td>100</td>
<td>0.00275</td>
<td>4.10e-05</td>
<td>0.00140</td>
<td>8.76e</td>
</tr>
<tr>
<td>1000</td>
<td>1000</td>
<td>0.146</td>
<td>0.000189</td>
<td>0.0787</td>
<td>0.0508</td>
</tr>
<tr>
<td>10000</td>
<td>10000</td>
<td>19.0</td>
<td>0.00234</td>
<td>9.97</td>
<td>5.57</td>
</tr>
</tbody>
</table>
</div>
<p>We can get much more insight using Python <a href="https://docs.python.org/3/library/profile.html">cProfile</a> module:</p>
<div class="highlight"><pre><span></span><code>python -m cProfile -s tottime timing.py 1000x1000 <span class="p">|</span> head -n <span class="m">20</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>nrow,ncol,filter col,select col,filter row,select row
1000,1000,0.18020892143249512,0.0003190040588378906,0.11076593399047852,0.07521200180053711
         2370750 function calls (2368230 primitive calls) in 0.666 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
  1836500    0.160    0.000    0.160    0.000 util.py:9(&lt;genexpr&gt;)
        1    0.090    0.090    0.180    0.180 df_col.py:66(filter)
     1000    0.084    0.000    0.084    0.000 timing.py:27(&lt;dictcomp&gt;)
     1000    0.076    0.000    0.076    0.000 df_col.py:71(&lt;dictcomp&gt;)
4842/2342    0.065    0.000    0.278    0.000 {built-in method builtins.all}
     1000    0.058    0.000    0.058    0.000 timing.py:16(&lt;listcomp&gt;)
     2500    0.052    0.000    0.276    0.000 util.py:5(dict_match)
        1    0.036    0.036    0.036    0.036 df_row.py:63(&lt;listcomp&gt;)
     1000    0.020    0.000    0.020    0.000 df_row.py:55(&lt;dictcomp&gt;)
   500005    0.012    0.000    0.012    0.000 {method &#39;append&#39; of &#39;list&#39; objects}
        1    0.006    0.006    0.666    0.666 timing.py:1(&lt;module&gt;)
        2    0.001    0.000    0.291    0.145 timing.py:35(time_filter)
        3    0.001    0.000    0.002    0.001 df_col.py:13(__init__)
</code></pre></div>
<p>Ignoring the first two lines (which are the output of our program),
the table tells us:</p>
<ul>
<li>
<p>the number of times each function or method was called;</p>
</li>
<li>
<p>the total time spent in those calls (which is what we care about most);</p>
</li>
<li>
<p>the time spent per call; and</p>
</li>
<li>
<p>the cumulative time spent in that call and all the things it calls,
    both per call and in total.</p>
</li>
</ul>
<p>Right away we can see that the <code>dict_match</code> function
that checks the consistency of the rows in a row-oriented dataframe
is eating up a lot of time.
It's only called in the constructor,
but on the other hand,
we're constructing a new dataframe for each <code>filter</code> and <code>select</code>,
so removing that check would actually speed things up.</p>
<p>Looking down a little further,
the dictionary comprehension in <code>DfCol.filter</code> takes a lot of time as well.
That isn't surprising:
we're copying the values out of the columns into a temporary dictionary
for every row when we filter,
and building all those temporary dictionaries adds up to a lot of time.</p>
<div class="callout">
<h3>Engineering</h3>
<p>If science is the use of the experimental method to investigate the world,
engineering is the use of the experimental method
to investigate and improve the things that people build.
Good software designers collect and analyze data all the time
to find out whether one website design works better than another <span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Kohavi2020">Kohavi2020</a>]</span>
or to improve the performance of CPUs <span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Patterson2017">Patterson2017</a>]</span>.
A few simple experiments like these can save weeks or months of misguided effort.</p>
</div>
<h2 id="dataframe-exercises">Section 4.4: Exercises</h2>
<h3 class="exercise">Empty dataframes</h3>
<p>An empty dataframe is as reasonable and as useful as an empty string or an empty list.
<code>DfCol</code> can represent this,
but <code>DfRow</code> cannot:
if the list of dictionaries is empty,
we cannot ask for columns' names.
Derive another dataframe class from <code>DF</code> that uses row-wise storage
but can represent a dataframe with no rows.</p>
<h3 class="exercise">Unified constructors</h3>
<p>Modify the constructors of <code>DfRow</code> and <code>DfCol</code> to have the same signatures.
Where and why might this be useful?</p>
<h3 class="exercise">Fixture functions</h3>
<p>Read the documentation for the <code>@fixture</code> decorator in <a href="https://docs.pytest.org/">pytest</a>
and the modify the tests in this chapter to use it.</p>
<h3 class="exercise">Using arrays</h3>
<p>Derive another dataframe class from <code>DF</code>
that uses Python's <a href="https://docs.python.org/3/library/array.html">array</a> module for column-wise storage.
How does it performance compared to other implementations?</p>
<h3 class="exercise">Crossover</h3>
<ol>
<li>
<p>At what ratio of filters to selects are <code>DfRow</code> and <code>DfCol</code> equally fast?
    (Your answer may depend on the size of the dataframe.)</p>
</li>
<li>
<p>How does the relative performance of the two classes change
    if tables have a fixed number of columns (such as 10 or 20)
    but an increasing numbers of rows?
    Is this scenario more realistic?</p>
</li>
</ol>
<h3 class="exercise">Filtering by strings</h3>
<p>Modify the comparison of filter and select to work with tables
that contain columns of strings instead of columns of numbers
and see how that changes performance.
For testing,
creating random 4-letter strings using the characters A-Z
and then filter by:</p>
<ul>
<li>an exact match,</li>
<li>strings starting with a specific character, and</li>
<li>strings that contain a specific character</li>
</ul>
<h3 class="exercise">Join performance</h3>
<p>A join combines data from two tables based on matching keys.
For example,
if the two tables are:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Left</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>a1</td>
</tr>
<tr>
<td>B</td>
<td>b1</td>
</tr>
<tr>
<td>C</td>
<td>c1</td>
</tr>
</tbody>
</table>
<p class="continue">and:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Right</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>a2</td>
</tr>
<tr>
<td>A</td>
<td>a3</td>
</tr>
<tr>
<td>B</td>
<td>b2</td>
</tr>
</tbody>
</table>
<p class="continue">then the join is:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Left</th>
<th>Right</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>a1</td>
<td>a2</td>
</tr>
<tr>
<td>A</td>
<td>a1</td>
<td>a3</td>
</tr>
<tr>
<td>B</td>
<td>b1</td>
<td>b2</td>
</tr>
</tbody>
</table>
<p>Write a test to compare the performance of row-wise vs. column-wise storage
when joining two tables based on matching numeric keys.
Does the answer depend on the fraction of keys that match?</p>
<h3 class="exercise">Join optimization</h3>
<p>The simplest way to <a class="gl-ref" href="../glossary/#join" markdown="1">join</a> two tables is
to look for matching keys using a double loop.
An alternative is to build an <a class="gl-ref" href="../glossary/#index_database" markdown="1">index</a> for each table
and then use it to construct matches.
For example, suppose the tables are:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Left</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>a1</td>
</tr>
<tr>
<td>B</td>
<td>b1</td>
</tr>
<tr>
<td>C</td>
<td>c1</td>
</tr>
</tbody>
</table>
<p class="continue">and:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Right</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>a2</td>
</tr>
<tr>
<td>A</td>
<td>a3</td>
</tr>
<tr>
<td>B</td>
<td>b2</td>
</tr>
</tbody>
</table>
<p>The first step is to create a <code>Map</code> showing where each key is found in the first table:</p>
<div class="highlight"><pre><span></span><code><span class="p">{</span><span class="nx">A</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="nx">B</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">],</span><span class="w"> </span><span class="nx">C</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mf">2</span><span class="p">]}</span><span class="w"></span>
</code></pre></div>
<p class="continue">The second step is to create a similar <code>Map</code> for the second table:</p>
<div class="highlight"><pre><span></span><code><span class="p">{</span><span class="nx">A</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">],</span><span class="w"> </span><span class="nx">B</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mf">2</span><span class="p">]}</span><span class="w"></span>
</code></pre></div>
<p class="continue">We can then loop over the keys in one of the maps,
look up values in the second map,
and construct all of the matches.</p>
<p>Write a function that joins two tables this way.
Is it faster or slower than using a double loop?
How does the answer depend on the number of keys and the fraction that match?</p>
        </main>
      </div>
    </div>
  </body>
</html>
